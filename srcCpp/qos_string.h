#include <string.h>
#define PERFTEST_QOS_STRING_SIZE 45
#define PERFTEST_QOS_STRING_TOTAL_SIZE 45850
const char * PERFTEST_QOS_STRING[PERFTEST_QOS_STRING_SIZE] = {
"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n\n<!--\n(c) 2005-2017  Copyright, Real-Time Innovations, Inc. All rights reserved.\nSubject to Eclipse Public License v1.0; see LICENSE.md for details.\n-->\n\n<!--\nThis file contains the QoS configurations used by the RTI PerfTest, a\nperformance test for measuring the latency of the middleware at different\nthroughput levels.\n\nThe format of this file is described in the RTI Connext Core Libraries\nand Utilities User's Manual in the chapter titled \"Configuring QoS with XML.\"\n-->\n\n<!--\nEquivalence between variable names and command-line options within the source code:\n\n_DataLen variable name corresponds to the command-line option -dataLen\n_SendQueueSize variable name corresponds to the command-line option -sendQueueSize\n_InstanceCount variable name corresponds to the command-line option -instances\n_InstanceHashBuckets variable name corresponds to the command-line option -instanceHashBuckets\n_KeepDurationUsec variable name corresponds to the command-line option -keepDurationU",
"sec\n\n-->\n\n<dds xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:noNamespaceSchemaLocation=\"https://community.rti.com/schema/5.3.0/rti_dds_profiles.xsd\">\n\n  <qos_library name=\"PerftestQosLibrary\">\n\n    <!-- ================================================================= -->\n    <!-- Base QoS Profile                                            -->\n    <!-- ================================================================= -->\n\n    <!--\n    This profile is used as the base for all the profiles defined in this XML file.\n    -->\n\n    <qos_profile name=\"BaseProfileQos\">\n      <participant_qos>\n        <!-- === Participant Configuration: ================================\n\n        The base configuration of the DomainParticipant object.\n\n        This element corresponds to the DomainParticipantQos type, which is described\n        in detail in the API Reference HTML documentation. Each child element corresponds\n        to a field in that structure with the same name. Any parameter not listed\n        here wi",
"ll pick up the documented default value.\n        -->\n        <receiver_pool>\n          <!--\n          The receive buffer is used by the receive thread to store the raw data\n          that arrives over the transport.\n\n          The ReceiverPoolQosPolicy's buffer_size should be set to be the same value\n          as the maximum ::NDDS_Transport_Property_t::message_size_max across all of\n          the transports being used.\n          -->\n          <buffer_size>65536</buffer_size>\n        </receiver_pool>\n\n        <resource_limits>\n          <!--\n          Maximum size of a serialized type code.\n\n          This parameter limits the size of the type code that a DomainParticipant\n          is able to store and propagate for data types.\n          -->\n          <type_code_max_serialized_length>2048</type_code_max_serialized_length>\n\n          <!--\n          Maximum string length of the properties associated with the DomainParticipant.\n\n          The string length is defined as the cumulative length, in bytes, includin",
"g the\n          null terminating characters, of all the (name,value) pairs associated with the\n          DomainParticipant properties.\n          -->\n          <participant_property_string_max_length>4096</participant_property_string_max_length>\n\n          <!--\n          Maximum number of properties associated with the DomainParticipant. Default is 32.\n          -->\n          <participant_property_list_max_length>64</participant_property_list_max_length>\n          <!--\n          Maximum length for content filter property in the DomainParticipant. Default is 256.\n          -->\n          <contentfilter_property_max_length>512</contentfilter_property_max_length>\n        </resource_limits>\n\n        <!--\n        Specifies which built-in transports are used.\n\n        Three different transport plug-ins are built into the Connext core\n        libraries (for most supported target platforms): UDPv4, shared memory, and\n        UDPv6.\n\n        By default RTI Perftest uses UDPv4|SHMEM, default values for RTI\n        Connex",
"t DDS. By using the command-line option -transport we enabled\n        the use of:\n\n        - UDPv4\n        - UDPv6\n        - SHMEM\n        - TCP\n        - TLS\n        - DTLS\n        - WAN\n\n        For custom transport settings, modify this profile.\n        -->\n\n        <!--\n        <transport_builtin>\n          <mask>UDPv4|SHMEM</mask>\n        </transport_builtin>\n        -->\n\n        <property>\n          <value>\n\n            <!--\n            Specifies the configuration to be used with the UDPv4 built-in transport.\n            -->\n            <element>\n              <name>dds.transport.UDPv4.builtin.parent.message_size_max</name>\n              <value>65536</value>\n            </element>\n            <element>\n              <name>dds.transport.UDPv4.builtin.send_socket_buffer_size</name>\n              <value>524288</value>\n            </element>\n            <element>\n              <name>dds.transport.UDPv4.builtin.recv_socket_buffer_size</name>\n              <value>2097152</value>\n            </element>\n\n      ",
"      <!--\n            Specifies the configuration to be used with the SHMEM built-in transport.\n\n            Important: The commented setting is configured automatically within the\n            source code. The default value of _DataLen is 100.\n\n            Value set in the source code:\n\n            <element>\n              <name>dds.transport.shmem.builtin.received_message_count_max</name>\n              <value>2097152/_DataLen</value>\n            </element>\n            -->\n            <element>\n              <name>dds.transport.shmem.builtin.parent.message_size_max</name>\n              <value>65536</value>\n            </element>\n            <element>\n              <name>dds.transport.shmem.builtin.receive_buffer_size</name>\n              <value>2097152</value>\n            </element>\n\n            <!--\n            Specifies the configuration to be used with the TCP transport.\n\n            If TCP is enabled using -transport TCP, the load_plugins property is set\n            within the source code.\n\n            Im",
"portant: nddstransporttcp.dll is located in NDDSHOME/lib/<architecture>.\n            That folder must be added to the PATH on Windows systems and LD_LIBRARY_PATH\n            on UNIX-based systems in order to load this library properly. If you are\n            compiling PerfTest using CSHARP, you must also add the folder\n            NDDSHOME/lib/i86Win32VS<version> or NDDSHOME/lib/x64Win64VS<version> depending\n            on the machine.\n\n            <element>\n              <name>dds.transport.load_plugins</name>\n              <value>dds.transport.TCPv4.tcp1</value>\n            </element>\n            -->\n            <element>\n              <name>dds.transport.TCPv4.tcp1.library</name>\n              <value>nddstransporttcp</value>\n            </element>\n            <element>\n              <name>dds.transport.TCPv4.tcp1.create_function</name>\n              <value>NDDS_Transport_TCPv4_create</value>\n            </element>\n            <element>\n              <name>dds.transport.TCPv4.tcp1.disable_nagle</name>\n     ",
"         <value>1</value>\n            </element>\n            <element>\n              <name>dds.transport.TCPv4.tcp1.parent.message_size_max</name>\n              <value>65536</value>\n            </element>\n\n            <!-- Defining flow controller 10Gbps. This will not enable it. -->\n            <element>\n              <name>dds.flow_controller.token_bucket.10Gbps.token_bucket.max_tokens</name>\n              <value>300</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.10Gbps.token_bucket.tokens_added_per_period</name>\n              <value>200</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.10Gbps.token_bucket.bytes_per_token</name>\n              <value>65536</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.10Gbps.token_bucket.period.sec</name>\n              <value>0</value>\n            </element>\n            <element>\n              <name>dds",
".flow_controller.token_bucket.10Gbps.token_bucket.period.nanosec</name>\n              <value>10000000</value>\n            </element>\n\n            <!-- Defining flow controller 1Gbps. This will not enable it. -->\n            <element>\n              <name>dds.flow_controller.token_bucket.1Gbps.token_bucket.max_tokens</name>\n              <value>30</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.1Gbps.token_bucket.tokens_added_per_period</name>\n              <value>20</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.1Gbps.token_bucket.bytes_per_token</name>\n              <value>65536</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.1Gbps.token_bucket.period.sec</name>\n              <value>0</value>\n            </element>\n            <element>\n              <name>dds.flow_controller.token_bucket.1Gbps.token_bucket.period.nanosec</name>\n        ",
"      <value>10000000</value>\n            </element>\n\n          </value>\n        </property>\n\n        <!--\n        Specifies the participant name. This setting is useful when using monitoring\n        applications.\n        -->\n        <participant_name>\n          <name>PerfTest Participant</name>\n        </participant_name>\n\n      </participant_qos>\n\n      <!-- === Publisher Configuration: ================================= \n        \n      The base configuration of the Publisher object.\n\n      This element corresponds to the PublisherQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <publisher_qos>\n        <presentation>\n          <!--\n          Access Scope: Determines the largest scope spanning the entities\n          for which the order and coherency of changes can be preserved.\n          \n      ",
"    Ordered Access: Specifies support for ordered access to the samples\n          received at the subscription end.\n          -->\n          <access_scope>TOPIC_PRESENTATION_QOS</access_scope>\n          <ordered_access>true</ordered_access>\n        </presentation>\n      </publisher_qos>\n\n      <!-- === Subscriber Configuration: ================================= \n      \n      The base configuration of the Subscriber object.\n\n      This element corresponds to the SubscriberQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <subscriber_qos>\n        <presentation>\n          <!--\n          Access Scope: Determines the largest scope spanning the entities\n          for which the order and coherency of changes can be preserved.\n          \n          Ordered Access: Specifies support for ordered access to th",
"e samples\n          received at the subscription end.\n          -->\n          <access_scope>TOPIC_PRESENTATION_QOS</access_scope>\n          <ordered_access>true</ordered_access>\n        </presentation>\n      </subscriber_qos>\n      \n      <!-- === DataWriter Configuration: ==================================\n      \n      The base configuration of the DataWriter object that produces throughput\n      data (the -pub side of the application).\n\n      This element corresponds to the DataWriterQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <datawriter_qos>\n        <resource_limits>\n          <!--\n          The number of instances for which the throughput DataWriter will\n          allocate space. The throughput topic is not keyed, so there is no \n          need for more than one instance.\n\n          Se",
"e Section 2.2 \"Data Types, Topics, Keys, Instances, and Samples\"\n          in the Connext Core Libraries and Utilities User's Manual \n          for more information about keys and instances.\n          \n          Important: These settings are configured automatically within the \n          source code. The default value of _InstanceCount is 1. The default\n          value of _InstanceHashBuckets is -1.\n          \n          <max_instances>_InstanceCount</max_instances>\n          <initial_instances>_InstanceCount</initial_instances>\n          \n          if _InstanceCount is greater than 1  \n            if _InstanceHashBuckets is greater than 0\n              <instance_hash_buckets>_InstanceHashBuckets</instance_hash_buckets>\n            \n            if _InstanceHashBuckets is equal or lower than 0\n              <instance_hash_buckets>_InstanceCount</instance_hash_buckets>\n          \n          -->\n        </resource_limits>\n        \n        <protocol>\n            <rtps_reliable_writer>\n                <!--\n         ",
"       When positive acknowledgements have been disabled, the DataWriter will \n                consider samples as positively \"acknowledged\" after this duration has \n                elapsed if it has not heard otherwise.\n                \n                We disable the positive acknowledgements in perftest by using:\n                -disablePositiveAcks. You can alternatively enable them via QoS by\n                adding <disable_positive_acks>true</disable_positive_acks> in the\n                <protocol> QoS of the DW and DR of the ThroughputQoS and LatencyQoS.\n\n                The default value of _KeepDurationUsec can be configured here or via the\n                command line parameter -keepDuration.\n                -->\n                <disable_positive_acks_min_sample_keep_duration>\n                    <sec>DURATION_ZERO_SEC</sec>\n                    <nanosec>100000</nanosec>\n                </disable_positive_acks_min_sample_keep_duration>\n            </rtps_reliable_writer>\n        </protocol>\n\n      </da",
"tawriter_qos>\n\n      <!-- === DataReader Configuration: ================================= -->\n\n      <!--\n      The base configuration of the DataReader object that consumes throughput\n      data (the -sub side of the application).\n\n      This element corresponds to the DataReaderQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <datareader_qos>\n        <resource_limits>\n          <!--\n          The initial and maximum number of instances for which the middleware\n          will allocate space. See the corresponding DataWriterQos comment above\n          for more information. \n          \n          Important: This settings are configured automatically within the source code.\n          The default value of _InstanceCount is 1.\n          The default value of _InstanceMaxCountReader is -1.\n          Th",
"e default value of _InstanceHashBuckets is -1.\n          \n          <max_instances>_InstanceMaxCountReader</max_instances>\n          <initial_instances>_InstanceCount</initial_instances>\n          \n          if _InstanceCount is greater than 1 and \n            if _InstanceHashBuckets is greater than 0\n              <instance_hash_buckets>_InstanceHashBuckets</instance_hash_buckets>\n            \n            if _InstanceHashBuckets is equal or lower than 0\n              <instance_hash_buckets>_InstanceCount</instance_hash_buckets>\n          \n          -->\n        </resource_limits>\n      </datareader_qos>\n      \n    </qos_profile>\n\n    <!-- ================================================================= -->\n    <!-- Throughput QoS Profile                                            -->\n    <!-- ================================================================= -->\n\n    <!--\n    This profile is used by the throughput-testing portion of the application,\n    provided that positive acknowledgements have not been di",
"sabled with the\n    '-noPositiveAcks' command-line argument or 'use positive acks = false'\n    in the .ini configuration file.\n    -->\n    <qos_profile name=\"ThroughputQos\" base_name=\"BaseProfileQos\">\n\n      <!-- === DataWriter Configuration: ================================= \n      \n      The base configuration of the DataWriter object that produces throughput\n      data (the -pub side of the application).\n\n      This element corresponds to the DataWriterQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <datawriter_qos>\n        <writer_resource_limits>\n          <max_remote_reader_filters>256</max_remote_reader_filters>\n        </writer_resource_limits>\n        <!--\n        Setting history.kind = KEEP_ALL, Connext will attempt to maintain\n        and deliver all the values of the instance to exi",
"sting subscribers. \n        The resources that Connext can use to keep this history are limited\n        by the settings of the RESOURCE_LIMITS.\n        -->\n        <history>\n          <kind>KEEP_ALL_HISTORY_QOS</kind>\n        </history>\n        <!--\n        Setting reliability.kind = RELIABLE_RELIABILITY_QOS, data samples \n        originating from a single DataWriter cannot be made available to the\n        DataReader if there are previous data samples that have not been \n        received yet due to a communication error.\n\n        The default value of reliability.kind is RELIABLE_RELIABILITY_QOS.\n        The reliability.kind can be modified to BEST_EFFORT_RELIABILITY_QOS\n        by using the command-line option -bestEffort.\n        -->\n        <reliability>\n          <kind>RELIABLE_RELIABILITY_QOS</kind>\n          <max_blocking_time>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </max_blocking_time>\n        </reliability>\n\n        <resource_limits>",
"\n          <!--\n          The number of data samples for which the DataWriter will allocate\n          space. The throughput test is configured without durability, meaning\n          that when all DataReaders have acknowledged a sample, the DataWriter\n          will discard it. The values below, then, effectively indicate how\n          far ahead of the slowest reader the writer is able to get before it\n          will block waiting for the reader(s) to catch up.\n\n          See the parallel DataReaderQos comment above for more information\n          about the relationships between these three values.\n          \n          Important: These settings are configured automatically within the \n          source code.\n            _SendQueueSize = 50 (default)\n            _SendQueueSize can be configured using the command-line option -sendQueueSize <value>\n          \n          if batching is not set:\n            <max_samples>_SendQueueSize</max_samples>\n            <initial_samples>_SendQueueSize</initial_samples>\n         ",
"   <max_samples_per_instance>_SendQueueSize</max_samples_per_instance>\n            \n          if batching is set:\n            <max_samples>DDS_LENGTH_UNLIMITED</max_samples>\n            <initial_samples>_SendQueueSize</initial_samples>\n            <max_samples_per_instance>DDS_LENGTH_UNLIMITED</max_samples_per_instance>\n          -->\n        </resource_limits>\n        \n        <protocol>\n          <rtps_reliable_writer>\n            <!--\n            When the writer's cache gets down to this number of samples, it\n            will slow the rate at which it sends heartbeats to readers.\n            \n            Important: This setting is configured automatically within the source code.\n            <low_watermark>_SendQueueSize * 0.1</low_watermark>\n            -->\n\n            <!--\n            When the writer's cache is filled to this level, it will begin\n            sending heartbeats at a faster rate in order to spur faster\n            acknowledgements (positive or negative) of its samples to allow it\n          ",
"  to empty its cache and avoid blocking.\n            \n            Important: This setting is configured automatically within the source code.\n            <high_watermark>_SendQueueSize * 0.9</high_watermark>\n            -->\n\n            <!--\n            Governs how often heartbeats are \"piggybacked\" on data samples.\n            \n            Important: This setting is configured automatically within the source code.\n            <heartbeats_per_max_samples>_SendQueueSize * 0.1</heartbeats_per_max_samples>\n            -->\n\n            <!-- \n            Minimum and maximum size of send window of unacknowledged samples.\n\n            Important: These settings are configured automatically within the source code.\n            <min_send_window_size>datawriter_qos.resource_limits.max_samples</min_send_window_size>\n            <max_send_window_size>datawriter_qos.resource_limits.max_samples</max_send_window_size>\n            -->\n\n            <!--\n            If the number of samples in the writer's cache hasn't risen to\n",
"            high_watermark, this is the rate at which the DataWriter will\n            send out periodic heartbeats.\n            -->\n            <heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>10000000</nanosec>\n            </heartbeat_period>\n            \n            <!--\n            If the number of samples in the writer's cache has risen to\n            high_watermark, and has not yet fallen to low_watermark, this is\n            the rate at which the writer will send periodic heartbeats to\n            its readers.\n            -->\n            <fast_heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>1000000</nanosec>\n            </fast_heartbeat_period>\n\n            <!--\n            If a durable reader starts up after the writer already has some\n            samples in its cache, this is the rate at which it will heartbeat\n            the new reader. It should generally be a shorter period of time\n            than the normal heartbeat period ",
"in order to help the new reader\n            catch up.\n            -->\n            <late_joiner_heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>10000000</nanosec>\n            </late_joiner_heartbeat_period>\n\n            <!--\n            The number of times a reliable writer will send a heartbeat to\n            a reader without receiving a response before it will consider the\n            reader to be inactive and no longer await acknowledgements before\n            discarding sent data.\n            -->\n            <max_heartbeat_retries>LENGTH_UNLIMITED</max_heartbeat_retries>\n\n            <!--\n            When a DataWriter receives a negative acknowledgement (NACK) from\n            a DataReader for a particular data sample, it will send a repair\n            packet to that reader.\n\n            The amount of time the writer waits between receiving the NACK and\n            sending the repair will be a random value between the minimum\n            and maximum values specified here",
". Narrowing the range, and\n            shifting it towards zero, will make the writer more reactive.\n            However, by leaving some delay you increase the chance that the\n            writer will learn of additional readers that missed the same data,\n            in which case it will be able to send a single multicast repair\n            instead of multiple unicast repairs, thereby using the available\n            network bandwidth more efficiently. The higher the fanout in your\n            system (i.e., the more readers per writer), and the greater the\n            load on your network, the more you should consider specifying a\n            non-zero delay here.\n            -->\n            <min_nack_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </min_nack_response_delay>\n            <max_nack_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </max_nack_response",
"_delay>\n          </rtps_reliable_writer>\n          \n        </protocol>\n\n        <!--\n        When sending many small data-samples, you can increated network efficiency \n        by batching multiple samples together in a single protocol-level message \n        (usually corresponding to a single network datagram). Batching can offer very \n        substantial throughput gains, but often at the expense of latency, although \n        in some configurations, the latency penalty can be very small or zero, \n        possibly even negative.\n        -->\n\n        <!-- \n        Important: This setting is configured automatically within the source code,\n        but only if batching is enabled. _SendQueueSize = 50 (default)\n        <writer_resource_limits>\n          <max_batches>_SendQueueSize</max_batches>\n        </writer_resource_limits>\n        -->\n\n        <batch>\n          <!--\n          This profile does not enable batching, although the remaining\n          batching settings are configured as if it did. To enable the",
" batch\n          configuration below, turn batching on using the app's command-line\n          or INI file.\n          -->\n          <enable>false</enable>\n\n          <!--\n          Batches can be \"flushed\" to the network based on a maximum size.\n          This size can be based on the total number of bytes in the\n          accumulated data samples, the total number of bytes in the\n          accumulated sample meta-data (e.g., timestamps, sequence numbers,\n          etc.), and/or the number of samples. Whenever the first of these\n          limits is reached, the batch will be flushed.\n          \n          Important: This setting is configured automatically within the source code.\n          <max_data_bytes>_BatchSize</max_data_bytes>\n          -->\n          <max_meta_data_bytes>LENGTH_UNLIMITED</max_meta_data_bytes>\n          <max_samples>LENGTH_UNLIMITED</max_samples>\n\n          <!--\n          The middleware will associate a source timestamp with a batch when\n          it is started. The duration below indicate",
"s the amount of time that\n          may pass before the middleware will insert an additional timestamp\n          into the middle of an existing batch.\n\n          Shortening this duration can give readers increased timestamp\n          resolution. However, lengthening this duration\n          decreases the amount of meta-data on the network, potentially\n          improving throughput, especially if the data samples are very small.\n          If this delay is set to an infinite time period, timestamps will\n          be inserted only once per batch. Furthermore, the middleware will\n          not need to check the time with each sample in the batch, reducing\n          the amount of computation on the send path and potentially improving\n          both latency and throughput performance.\n          -->\n          <source_timestamp_resolution>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </source_timestamp_resolution>\n\n          <!--\n          The maximum fl",
"ush delay. A batch is flushed automatically after the \n          delay specified by this parameter. As its value is DURATION_INFINITE, \n          the flush event will be triggered by max_data_bytes.\n          -->\n          <max_flush_delay>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </max_flush_delay>\n\n          <!--\n          By default, the same DataWriter can be used from multiple threads.\n          If you know that your application will only write data from a single\n          thread, you can switch off a level of locking that occurs when\n          samples are added to a batch. When sending very small samples very\n          fast, this decreased overhead can improve performance.\n\n          However, even in the case of single-threaded access, the impact of\n          locking can be negligible, and deactivating the lock puts your\n          application at risk of memory corruption if multiple threads do\n          write to the same DataWriter - ei",
"ther without your knowledge or as\n          a result of application maintenance. Therefore, RTI recommends that\n          you only set thread_safe_write to false after detailed testing has\n          confirmed that your application does indeed behave correctly and\n          with improved performance.\n          -->\n          <thread_safe_write>false</thread_safe_write>\n        </batch>\n\n        <writer_data_lifecycle>\n          <autodispose_unregistered_instances>false</autodispose_unregistered_instances>\n        </writer_data_lifecycle>\n\n      </datawriter_qos>\n\n      <!-- === DataReader Configuration: ================================= -->\n\n      <!--\n      The base configuration of the DataReader object that consumes throughput\n      data (the -sub side of the application).\n\n      This element corresponds to the DataReaderQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      paramete",
"r not listed here will pick up the documented default value.\n      -->\n      <datareader_qos>\n\n        <!--\n        Setting history.kind = KEEP_ALL, Connext will attempt to maintain\n        and deliver all the values of the instance to existing subscribers.\n        The resources that Connext can use to keep this history are limited\n        by the settings of the RESOURCE_LIMITS.\n        -->\n        <history>\n          <kind>KEEP_ALL_HISTORY_QOS</kind>\n        </history>\n\n        <!--\n        Setting reliability.kind = RELIABLE_RELIABILITY_QOS, data samples\n        originating from a single DataWriter cannot be made available to the\n        DataReader if there are previous data samples that have not been\n        received yet due to a communication error.\n\n        The default value of reliability.kind is RELIABLE_RELIABILITY_QOS.\n        The reliability.kind can be modified to BEST_EFFORT_RELIABILITY_QOS\n        by using the command-line option -bestEffort.\n        -->\n        <reliability>\n          <kind>RELI",
"ABLE_RELIABILITY_QOS</kind>\n        </reliability>\n\n        <!--\n        DurabilityQos policy specifies whether or not Connext will store and\n        deliver previously published data samples to new DataReaders\n        that join the network later.\n\n        Important: durability.kind and durability.direct_communication are configured\n        automatically within the source code. To modify them, use the input commands\n        -durability and -noDirectCommunication.\n\n        The default value of _DirectCommunication is true.\n        The default value of _Durability is DDS_VOLATILE_DURABILITY_QOS.\n\n        <durability>\n          <kind>_Durability</kind>\n          <direct_communication>_DirectCommunication</direct_communication>\n        </durability>\n        -->\n\n        <resource_limits>\n          <!--\n          The initial and maximum number of data samples. The middleware will\n          make sure to allocate space for the initial_samples, and then if\n          needed, it will grow the allocated memory up to a p",
"oint where it\n          supports max_samples.\n\n          For the initial number of samples we choose a number that should be\n          enough for most use-cases (therefore no need to grow), but that\n          should not affect the memory consumption by reserving too much\n          memory.\n          -->\n          <max_samples>10000</max_samples>\n          <initial_samples>128</initial_samples>\n\n          <!--\n          The maximum number of samples that can be stored for a single\n          instance. If the throughput topic is not keyed, there is only a\n          single instance, so this value should always be set the same\n          as max_samples.\n\n          For a keyed topic, you might want to use this parameter to institute\n          a degree of \"fairness\" among the instances.\n          -->\n          <max_samples_per_instance>10000</max_samples_per_instance>\n        </resource_limits>\n\n        <reader_resource_limits>\n          <!--\n          The maximum number of samples that Connext will store from a\n     ",
"     single DataWriter. If you run this application with only a single\n          DataWriter (that is, in a one-to-one or one-to-many configuration),\n          there is no reason for this value to be set to anything less than\n          max_samples. If you have many writers and need to institute\n          a degree of \"fairness\" among them, you can decrease this value.\n          -->\n          <max_samples_per_remote_writer>10000</max_samples_per_remote_writer>\n\n          <!--\n          The maximum number of data samples that the application can receive\n          from Connext in a single call to DataReader::read() or\n          take(). If more data exists in the middleware, the application will\n          need to issue multiple read()/take() calls.\n\n          When reading data using listeners, the expected number of samples\n          available for delivery in a single take() call is typically small:\n          usually just one in the case of unbatched data, or the number of\n          samples in a single batch in the",
" case of batched data. When polling\n          for data or using Waitsets, however, multiple samples (or batches)\n          could be retrieved at once, depending on the data rate.\n\n          A larger value for this parameter makes the API simpler to use, at\n          the expense of some additional memory consumption.\n          -->\n          <max_samples_per_read>65536</max_samples_per_read>\n        </reader_resource_limits>\n\n        <protocol>\n          <rtps_reliable_reader>\n            <!--\n            When the DataReader receives a heartbeat from a DataWriter\n            (indicating (a) that the DataWriter still exists on the network\n            and (b) what sequence numbers it has published), the following\n            parameters indicate how long it will wait before replying with\n            a positive (assuming they aren't disabled) or negative\n            acknowledgement.\n\n            The time the reader waits will be a random duration between\n            the minimum and maximum values. Narrowing this ra",
"nge, and shifting\n            it towards zero, will make the system more reactive. However, it\n            increases the chance of (N)ACK spikes. The higher the fanout in\n            your system (i.e., the number of readers per writer), the more\n            you should consider specifying a range here.\n            -->\n            <min_heartbeat_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </min_heartbeat_response_delay>\n            <max_heartbeat_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </max_heartbeat_response_delay>\n          </rtps_reliable_reader>\n        </protocol>\n      </datareader_qos>\n\n    </qos_profile>\n\n\n    <!-- ================================================================= -->\n    <!-- Latency QoS Profile                                               -->\n    <!-- ================================================================= -->\n\n   ",
" <!--\n    This profile is used by the latency-testing portion of the application,\n    provided that positive acknowledgements have not been disabled with the\n    '-noPositiveAcks' command-line argument or 'use positive acks = false'\n    INI file configuration.\n    -->\n    <qos_profile name=\"LatencyQos\" base_name=\"BaseProfileQos\">\n\n      <!-- === DataWriter Configuration: ================================= \n      \n      The base configuration of the DataWriter object that consumes latency\n      data (on the -sub side of the application).\n\n      This element corresponds to the DataWriterQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <datawriter_qos>\n        <!--\n        Setting history.kind = KEEP_ALL, Connext will attempt to maintain\n        and deliver all the values of the instance to existing",
" subscribers. \n        The resources that Connext can use to keep this history are limited\n        by the settings of the RESOURCE_LIMITS.\n        -->\n        <history>\n          <kind>KEEP_ALL_HISTORY_QOS</kind>\n        </history>\n\n        <!--\n        Setting reliability.kind = RELIABLE_RELIABILITY_QOS, data samples \n        originating from a single DataWriter cannot be made available to the\n        DataReader if there are previous data samples that have not been \n        received yet due to a communication error.\n\n        The default value is RELIABLE_RELIABILITY_QOS.\n        It can be modified to BEST_EFFORT_RELIABILITY_QOS\n        using the command-line option -bestEffort.\n        -->\n        <reliability>\n          <kind>RELIABLE_RELIABILITY_QOS</kind>\n          <max_blocking_time>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </max_blocking_time>\n        </reliability>\n\n        <!--\n        \n        The Durability QoS policy specifies whet",
"her or not Connext will store and \n        deliver previously published data samples to new DataReaders that join the \n        network later.\n        \n        Important: durability.kind and durability.direct_communication are configured\n        automatically within the source code. To modify them, use the input commands\n        -durability and -noDirectCommunication.\n        \n        The default value of _DirectCommunication is true.\n        The default value of _Durability is DDS_VOLATILE_DURABILITY_QOS\n        \n        if _DirectCommunication is false\n          if _Durability is DDS_TRANSIENT_DURABILITY_QOS or DDS_PERSISTENT_DURABILITY_QOS\n            <durability>\n              <kind>_Durability</kind>\n              <direct_communication>_DirectCommunication</direct_communication>\n            </durability>\n        -->\n        \n        <!--\n        The number of samples for which Connext will set aside space.\n        See the comments above for more information.\n        -->\n        <resource_limits>\n         ",
" <max_samples>LENGTH_UNLIMITED</max_samples>\n          <initial_samples>100</initial_samples>\n          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>\n        </resource_limits>\n        \n        <!--\n        The behavioral contract under which the DataWriter will carry out the\n        reliability protocol. See the comments above for more information.\n        -->\n        <protocol>\n          <rtps_reliable_writer>\n            <low_watermark>10</low_watermark>\n            <high_watermark>100</high_watermark>\n            <heartbeats_per_max_samples>1000</heartbeats_per_max_samples>\n            <heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>10000000</nanosec>\n            </heartbeat_period>\n            <fast_heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>1000000</nanosec>\n            </fast_heartbeat_period>\n            <late_joiner_heartbeat_period>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>1",
"0000000</nanosec>\n            </late_joiner_heartbeat_period>\n            <max_heartbeat_retries>LENGTH_UNLIMITED</max_heartbeat_retries>\n            <min_nack_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </min_nack_response_delay>\n            <max_nack_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </max_nack_response_delay>\n            <min_send_window_size>LENGTH_UNLIMITED</min_send_window_size>\n            <max_send_window_size>LENGTH_UNLIMITED</max_send_window_size>\n          </rtps_reliable_writer>\n        </protocol>\n\n        <writer_data_lifecycle>\n          <autodispose_unregistered_instances>false</autodispose_unregistered_instances>\n        </writer_data_lifecycle>\n\n      </datawriter_qos>\n\n\n      <!-- === DataReader Configuration: ================================= \n      \n      The base configuration of the DataReader object that consumes latency",
"\n      data (on the -pub side of the application).\n\n      This element corresponds to the DataReaderQos type, which is described\n      in detail in the API Reference HTML documentation. Each child element\n      corresponds to a field in that structure with the same name. Any\n      parameter not listed here will pick up the documented default value.\n      -->\n      <datareader_qos>\n        <!--\n        The default value of reliability.kind is RELIABLE_RELIABILITY_QOS. \n        \n        The reliability.kind can be modified to BEST_EFFORT_RELIABILITY_QOS\n        by using the command-line option -bestEffort.\n        -->\n        <reliability>\n          <kind>RELIABLE_RELIABILITY_QOS</kind>\n        </reliability>\n\n        <!--\n        DurabilityQos policy specifies whether or not Connext will store and \n        deliver previously published data samples to new DDSDataReader entities \n        that join the network later.\n        \n        Important: durability.kind and durability.direct_communication are configured\n  ",
"      automatically within the source code. To modify them, use the input commands\n        -durability and -noDirectCommunication.\n        \n        The default value of _DirectCommunication is true.\n        The default value of _Durability is DDS_VOLATILE_DURABILITY_QOS\n        \n        if _DirectCommunication is false\n          if _Durability is DDS_TRANSIENT_DURABILITY_QOS or DDS_PERSISTENT_DURABILITY_QOS\n            <durability>\n              <kind>_Durability</kind>\n              <direct_communication>_DirectCommunication</direct_communication>\n            </durability>\n        -->\n        \n        <!--\n        The number of samples for which the middleware will set aside space.\n        See the comments above for more information.\n        -->\n        <resource_limits>\n          <max_samples>100</max_samples>\n          <initial_samples>100</initial_samples>\n          <max_samples_per_instance>100</max_samples_per_instance>\n        </resource_limits>\n\n        <reader_resource_limits>\n          <max_samples_",
"per_remote_writer>100</max_samples_per_remote_writer>\n        </reader_resource_limits>\n\n        <!--\n        The behavioral contract under which the DataReader will carry out the\n        reliability protocol. See the comments above for more information.\n        -->\n        <protocol>\n          <rtps_reliable_reader>\n            <min_heartbeat_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </min_heartbeat_response_delay>\n            <max_heartbeat_response_delay>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </max_heartbeat_response_delay>\n            <heartbeat_suppression_duration>\n              <sec>DURATION_ZERO_SEC</sec>\n              <nanosec>DURATION_ZERO_NSEC</nanosec>\n            </heartbeat_suppression_duration>\n          </rtps_reliable_reader>\n        </protocol>\n      </datareader_qos>\n      \n    </qos_profile>\n\n    <!-- =========================================",
"======================== -->\n    <!-- Announcement QoS Profile                                          -->\n    <!-- ================================================================= -->\n\n    <!--\n    This profile is used by the test harness for the announcement topic,\n    which is used to synchronize the publishing and subscribing size\n    to start the test.  Basically, the announcement should be sent/received\n    reliably.\n\n    Note: this profile derives from the Latency QoS so we do not have to duplicate\n    the Reliability QoS protocol settings.\n    -->\n    <qos_profile name=\"AnnouncementQos\" base_name=\"LatencyQos\">\n\n      <!-- === DataReader Configuration: ================================= -->\n\n      <datareader_qos>\n        <reliability>\n          <kind>RELIABLE_RELIABILITY_QOS</kind>\n          <max_blocking_time>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </max_blocking_time>\n        </reliability>\n        \n        <history>\n          <k",
"ind>KEEP_ALL_HISTORY_QOS</kind>\n        </history>\n        <durability>\n          <kind>DDS_TRANSIENT_LOCAL_DURABILITY_QOS</kind>\n        </durability>\n      </datareader_qos>\n\n      <!-- === DataWriter Configuration: ================================= -->\n\n      <datawriter_qos>\n        <reliability>\n          <kind>RELIABLE_RELIABILITY_QOS</kind>\n          <max_blocking_time>\n            <sec>DURATION_INFINITE_SEC</sec>\n            <nanosec>DURATION_INFINITE_NSEC</nanosec>\n          </max_blocking_time>\n        </reliability>\n        \n        <history>\n          <kind>KEEP_ALL_HISTORY_QOS</kind>\n        </history>\n        <durability>\n          <kind>DDS_TRANSIENT_LOCAL_DURABILITY_QOS</kind>\n        </durability>\n      </datawriter_qos>\n    </qos_profile>\n  </qos_library>\n</dds>\n" };

#define PERFTEST_QOS_STRING_asString(str) {\
       int i;\
       (str)[0] = 0;\
       for(i = 0; i < PERFTEST_QOS_STRING_SIZE; ++i) {\
            strcat(str, PERFTEST_QOS_STRING[i]);\
       }\
}
